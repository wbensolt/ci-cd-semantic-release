# Nom du workflow qui appara√Æt dans l'interface GitHub Actions
name: Release

# D√©finit quand ce workflow doit s'ex√©cuter
on:
    # S'ex√©cute automatiquement sur push vers main/develop (apr√®s merge de PR)
    push:
        branches:
            - main               # Push sur la branche principale (production)
            - develop            # Push sur la branche de d√©veloppement (pre-releases)

# Permissions par d√©faut pour tous les jobs du workflow
permissions:
    contents: read      # Lecture du contenu du repository
    packages: write     # √âcriture des packages (pour Docker registry)
    pull-requests: write

# D√©finit les diff√©rentes t√¢ches (jobs) √† ex√©cuter
jobs:
    # Job pour cr√©er une nouvelle version et publier la release
    release:
        name: Release
        runs-on: ubuntu-latest    # Utilise la derni√®re version d'Ubuntu
        # Emp√™che plusieurs releases simultan√©es sur la m√™me branche
        concurrency: release-${{ github.ref }}
        # Permissions sp√©cifiques pour ce job (√©crasent les permissions globales)
        permissions:
            id-token: write     # N√©cessaire pour l'authentification OIDC
            contents: write     # √âcriture du contenu (cr√©er des tags, commits)
            packages: write     # Publication de packages
        # Outputs permettent de partager des donn√©es avec d'autres jobs
        outputs:
            version: ${{ steps.get_version.outputs.version }}  # Expose la version cr√©√©e
        steps:
            # √âtape 1: G√©n√®re un token d'authentification depuis une GitHub App
            - name: Genarate App Token
              id: get_token  # ID pour r√©f√©rencer les outputs de cette √©tape
              uses: actions/create-github-app-token@v2  # Action officielle pour cr√©er un token
              with:
                app-id: ${{ secrets.APP_ID }}           # ID de l'application (stock√© dans les secrets)
                private-key: ${{ secrets.PRIVATE_KEY }} # Cl√© priv√©e de l'app (stock√©e dans les secrets)

            # √âtape 2: R√©cup√®re le code source du repository
            - name: Checkout
              uses: actions/checkout@v5.0.0  # Action officielle GitHub pour cloner le repo
              with:
                token: ${{ steps.get_token.outputs.token }}  # Utilise le token de l'app (plus de permissions)
                fetch-depth: 0  # R√©cup√®re tout l'historique Git (n√©cessaire pour semantic-release)

            # √âtape 2b: Force le checkout de la branche (√©vite detached HEAD)
            - name: Checkout branch
              run: |
                BRANCH_NAME="${GITHUB_REF#refs/heads/}"
                echo "Checking out branch: $BRANCH_NAME"
                git checkout "$BRANCH_NAME"

            # √âtape 3: Installe uv (gestionnaire de paquets Python)
            - name: astral-sh/setup-uv
              uses: astral-sh/setup-uv@v7.1.2
              with:
                version: "latest"  # Utilise la derni√®re version stable

            # √âtape 4: Installe Python Semantic Release comme outil
            - name: Install Python Semantic Release
              run: |
                # uv tool install : Installe un outil Python en isolation
                # python-semantic-release : Outil pour versionning s√©mantique automatique
                uv tool install python-semantic-release

            # √âtape 5: G√©n√®re une nouvelle version et publie la release
            - name: Semantic Versioning
              id: semantic
              env:
                # Token n√©cessaire pour cr√©er des releases sur GitHub
                GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
                GH_TOKEN: ${{ steps.get_token.outputs.token }}
              run: |
                # Configure l'identit√© Git pour les commits automatiques
                git config user.name "WaelCheck-bot[bot]"
                git config user.email "WaelCheck-bot[bot]@users.noreply.github.com"

                # uv run : Ex√©cute la commande dans l'environnement de l'outil install√©
                # version --changelog : D√©termine la nouvelle version et met √† jour le changelog
                uv run semantic-release version --changelog

                # publish : Cr√©e le tag Git et la release GitHub (uniquement sur main)
                if [ "${{ github.ref }}" == "refs/heads/main" ]; then
                  echo "üì¶ Creating GitHub Release (main branch)"
                  uv run semantic-release publish
                else
                  echo "‚è≠Ô∏è Skipping GitHub Release (develop branch - pre-release only)"
                  # Sur develop, on push juste le tag Git sans cr√©er de GitHub Release
                  git push --follow-tags origin HEAD
                fi

            # √âtape 6: R√©cup√®re la version cr√©√©e pour l'exposer aux autres jobs
            - name: Get Version
              id: get_version
              run: |
                # R√©cup√®re le dernier tag Git (qui correspond √† la version cr√©√©e)
                VERSION=$(git describe --tags --abbrev=0)
                # Exporte la version dans les outputs du job
                echo "version=$VERSION" >> $GITHUB_OUTPUT

    # Job pour construire et publier l'image Docker
    build-and-push-docker:
        name: Build & Push Docker Image
        runs-on: ubuntu-latest          # Utilise la derni√®re version d'Ubuntu
        needs: release                  # Ce job attend que le job 'release' soit termin√©
        if: github.ref == 'refs/heads/main'  # Uniquement sur main (pas de Docker image pour develop)
        permissions:
            contents: read      # Lecture du contenu du repository
            packages: write     # √âcriture dans le registry GitHub Container Registry
        steps:
            # √âtape 1: R√©cup√®re le code source pour construire l'image
            - name: Checkout
              uses: actions/checkout@v5.0.0
              with:
                fetch-depth: 0  # R√©cup√®re tout l'historique Git

            # √âtape 2: Authentification au GitHub Container Registry
            - name: Login to Docker Hub
              uses: docker/login-action@v3.6.0  # Action officielle Docker pour se connecter
              with:
                registry: ghcr.io                          # GitHub Container Registry
                username: ${{ github.actor }}              # Nom d'utilisateur GitHub qui ex√©cute le workflow
                password: ${{ secrets.GITHUB_TOKEN }}      # Token GitHub automatique (cr√©√© par GitHub Actions)

            - name: Extract metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                images: ghcr.io/${{ github.repository }}
                tags: |
                  type=raw,value=${{ needs.release.outputs.version }}
                  type=raw,value=latest
                labels: |
                  org.opencontainers.image.version=${{ needs.release.outputs.version }}
                  org.opencontainers.image.revision=${{ github.sha }}

            - name: Build Docker image (ne pas pousser)
              id: docker_build
              uses: docker/build-push-action@v5
              with:
                context: .
                file: Dockerfile
                push: false
                tags: ${{ steps.meta.outputs.tags }}
                labels: ${{ steps.meta.outputs.labels }}
                load: true

            - name: Scanner l'image avec Trivy
              uses: aquasecurity/trivy-action@master
              with:
                image-ref: ghcr.io/${{ github.repository }}:${{ needs.release.outputs.version }}
                format: "table"
                exit-code: "1"
                ignore-unfixed: true
                severity: "CRITICAL,HIGH"

            - name: Pousser l'image Docker (si le scan a r√©ussi)
              uses: docker/build-push-action@v5
              with:
                context: .
                file: Dockerfile
                push: true
                tags: ${{ steps.meta.outputs.tags }}
                labels: ${{ steps.meta.outputs.labels }}
